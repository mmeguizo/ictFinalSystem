generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  DEVELOPER
  TECHNICAL
  SECRETARY
  DIRECTOR
  MIS_HEAD
  ITS_HEAD
  USER
}

enum TicketType {
  MIS
  ITS
}

enum TicketStatus {
  FOR_REVIEW
  REVIEWED
  DIRECTOR_APPROVED
  ASSIGNED
  PENDING_ACKNOWLEDGMENT
  SCHEDULED
  IN_PROGRESS
  ON_HOLD
  RESOLVED
  CLOSED
  CANCELLED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum MISCategory {
  WEBSITE
  SOFTWARE
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  password  String?
  role      Role     @default(USER)
  externalId String? @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  picture   String?
  // URL to a user-uploaded avatar hosted by our app (preferred for profile overrides)
  avatarUrl String?
  lastLoginAt DateTime?
  
  // Ticket relationships
  createdTickets      Ticket[]           @relation("TicketCreator")
  assignedTickets     TicketAssignment[]
  ticketNotes         TicketNote[]
  statusHistoryEntries TicketStatusHistory[]
  
  // Notifications
  notifications       Notification[]
  
  // Attachments
  uploadedAttachments  TicketAttachment[] @relation("AttachmentUploader")
  deletedAttachments   TicketAttachment[] @relation("AttachmentDeleter")


  isActive            Boolean   @default(true)
  deactivatedAt        DateTime?
  deactivatedById      Int?
 
  @@index([role])
  @@index([isActive]) 
}

model Ticket {
  id                Int      @id @default(autoincrement())
  ticketNumber      String   @unique
  controlNumber     String?      @unique  
  type              TicketType
  title             String
  description       String   @db.Text
  status            TicketStatus @default(FOR_REVIEW)
  priority          Priority     @default(MEDIUM)
  
  // SLA tracking
  dueDate           DateTime?
  estimatedDuration Int?      // in hours
  actualDuration    Int?      // in hours
  
  // Review/Approval workflow
  secretaryReviewedById  Int?
  secretaryReviewedAt    DateTime?
  directorApprovedById   Int?
  directorApprovedAt     DateTime?
  
  // Schedule workflow (Head sets dates, Admin acknowledges)
  dateToVisit            DateTime?
  targetCompletionDate   DateTime?
  headScheduledById      Int?
  headScheduledAt        DateTime?
  adminAcknowledgedById  Int?
  adminAcknowledgedAt    DateTime?
  
  // Monitoring (Head adds after visit)
  monitorNotes           String?   @db.Text
  recommendations        String?   @db.Text
  monitoredById          Int?
  monitoredAt            DateTime?
  
  // Relationships
  createdById       Int
  createdBy         User      @relation("TicketCreator", fields: [createdById], references: [id])
  
  // Polymorphic content
  misTicket         MISTicket?
  itsTicket         ITSTicket?
  
  // Collections
  assignments       TicketAssignment[]
  notes             TicketNote[]
  attachments       TicketAttachment[]
  statusHistory     TicketStatusHistory[]
  notifications     Notification[]
  
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  resolvedAt        DateTime?
  closedAt          DateTime?
  
  @@index([status])
  @@index([createdById])
  @@index([type])
}

model MISTicket {
  id              Int         @id @default(autoincrement())
  ticketId        Int         @unique
  ticket          Ticket      @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  category        MISCategory
  
  // Website fields
  websiteNewRequest Boolean   @default(false)
  websiteUpdate     Boolean   @default(false)
  
  // Software fields
  softwareNewRequest Boolean  @default(false)
  softwareUpdate     Boolean  @default(false)
  softwareInstall    Boolean  @default(false)
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
}

model ITSTicket {
  id                    Int      @id @default(autoincrement())
  ticketId              Int      @unique
  ticket                Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  // Borrow fields
  borrowRequest         Boolean  @default(false)
  borrowDetails         String?  @db.Text
  
  // Maintenance fields
  maintenanceDesktopLaptop  Boolean @default(false)
  maintenanceInternetNetwork Boolean @default(false)
  maintenancePrinter        Boolean @default(false)
  maintenanceDetails        String? @db.Text
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
}

model TicketAssignment {
  id              Int      @id @default(autoincrement())
  ticketId        Int
  ticket          Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  userId          Int
  user            User     @relation(fields: [userId], references: [id])
  
  assignedAt      DateTime @default(now())
  
  @@unique([ticketId, userId])
  @@index([userId])
}

model TicketNote {
  id              Int      @id @default(autoincrement())
  ticketId        Int
  ticket          Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  userId          Int
  user            User     @relation(fields: [userId], references: [id])
  
  content         String   @db.Text
  isInternal      Boolean  @default(false) // Internal notes only visible to staff
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([ticketId])
  @@index([userId])
}

model TicketAttachment {
  id              Int      @id @default(autoincrement())
  ticketId        Int
  ticket          Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  filename        String
  originalName    String
  mimeType        String
  size            Int
  url             String
  
  // Who uploaded this file
  uploadedById    Int?
  uploadedBy      User?    @relation("AttachmentUploader", fields: [uploadedById], references: [id])
  
  // Soft delete tracking
  isDeleted       Boolean  @default(false)
  deletedAt       DateTime?
  deletedById     Int?
  deletedBy       User?    @relation("AttachmentDeleter", fields: [deletedById], references: [id])
  
  createdAt       DateTime @default(now())
  
  @@index([ticketId])
  @@index([uploadedById])
}

model TicketStatusHistory {
  id              Int          @id @default(autoincrement())
  ticketId        Int
  ticket          Ticket       @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  userId          Int
  user            User         @relation(fields: [userId], references: [id])
  
  fromStatus      TicketStatus?
  toStatus        TicketStatus
  comment         String?      @db.Text
  
  createdAt       DateTime     @default(now())
  
  @@index([ticketId])
}


model TicketCounter {
  id      Int @id @default(autoincrement())
  year    Int
  month   Int
  counter Int @default(0)
  
  @@unique([year, month])
}

// ========================================
// NOTIFICATION SYSTEM
// ========================================

enum NotificationType {
  TICKET_CREATED
  TICKET_REVIEWED
  TICKET_REJECTED
  TICKET_APPROVED
  TICKET_DISAPPROVED
  TICKET_ASSIGNED
  STATUS_CHANGED
  NOTE_ADDED
}

model Notification {
  id              Int              @id @default(autoincrement())
  
  // Who should receive this notification
  userId          Int
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Related ticket (optional - some notifications may not be ticket-related)
  ticketId        Int?
  ticket          Ticket?          @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  // Notification content
  type            NotificationType
  title           String
  message         String           @db.Text
  
  // Read status
  isRead          Boolean          @default(false)
  readAt          DateTime?
  
  // Metadata (stores extra info like actor name, old/new status, etc.)
  metadata        Json?
  
  createdAt       DateTime         @default(now())
  
  @@index([userId, isRead])
  @@index([ticketId])
  @@index([createdAt])
}
